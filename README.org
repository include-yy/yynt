#+DATE: [2024-01-01]

* yynt --- a simple Org publish manager

(If you are familiar with Org-mode and have used Org's export and publishing
features, I hope this package can be helpful when needed; otherwise, it might
not be very useful at the moment.)

Just like =ox-publish=, =yynt= is a management tool for exporting Org files to
other types of files (such as HTML, Markdown). It allows for the management of a
series of Org files and their associated resource files by writing publication
configurations. For building a blog, such management tools can help us retain
the original directory structure, generate HTML at the target location, and move
the associated resource files.

** Features

Compared to =ox-publish=, =yynt= has the following advantages:

- Project-local Cache File and More
- More Flexible(Complex) Export Options Configuration
- Able to Describe Simple File Dependencies
- Clear Directory Structure Differentiation

I don't list disadvantages here, but actually =yynt= is not an out-of-the-box
package; you need to write publication rules according to your needs (which
might require hundreds of lines of Elisp :p ).

** Design

When I use Org to write blogs, I want a file that can aggregate information from
other files, such as titles and categories. This requires me to read the
contents of certain files, and this file is special because it may need to be
re-exported due to changes in other files. To avoid repeatedly reading files, I
can store certain information when exporting regular files and use this
information when exporting special files. Additionally, I can ensure that
special files are also exported after regular files to keep the information up
to date.

To achieve the above goals, I implemented a caching function based on Emacs
SQLite support. It records the export time, publication time, file path, and
keyword strings from the file header when exporting regular files. These
timestamps can be used for incremental updates during export or publication, and
the keyword information can be used for the export of special files without
multiple file reads. Users can set the keywords that need to be read.

I divide files into regular files and ex files. The former are exported earlier
in the process, and the latter can utilize the information in the database from
the former. Regular files in one project can become dependencies for ex files in
another project. When multiple projects are exported simultaneously, I ensure
that ex files are always exported later than all regular files.

Instead of placing blog files in a folder and then centrally placing resources
(such as images, videos, code files, etc.) in another folder, I prefer to
prepare a folder for each blog, placing the Org file and its associated resource
files in the folder. I have different project types for different directory
structures: 0 represents a single file, 1 represents a single-layer directory,
and 2 represents a two-layer directory. Compared to recursively searching for
export files like ox-publish, clearly distinguishing between different directory
structures may be clearer.

** Installation

You can it using =package-vc= (require Emacs 29.1 or above):

#+begin_src text
M-x package-vc-install https://github.com/include-yy/yynt RET
#+end_src

After installation, add =(require 'yynt)= to your init file or somewhere using functions from yynt.el.

** Configuration

*** Create Project

In yynt, a project can be compared to a combination object in =ox-publish=. It
consists of one or more build objects. We can use =yynt-create-project= to create
a project object. =yynt-create-project= has the following parameters:

#+begin_src elisp
  (defun yynt-create-project (name pubdir cache cache-items &optional directory) ...)
#+end_src

- =NAME=: Project name symbol
  - Project names cannot be =t=, =nil=, or keywords.
- =PUBDIR=: Publish directory
  - If it's a relative path, it is relative to the project's root directory.
- =CACHE=: Cache file name
  - If it's a relative path, it is relative to the project's directory. If it is
    =nil=, it means the project does not use a cache.
- =CACHE-ITEMS=: List of keywords
  - A list of keywords collected from the beginning of Org files during export
    and publishing processes.
- =DIRECTORY=: Project root directory
  - If omitted, it defaults to the current directory at the time of the call.

When calling =yynt-create-project=, it will create and return a =yynt-project=
object. If =CACHE= is not =nil=, it will create and initialize a database file
if not exists. The created project will be stored in the =yynt-project-list=
list, and users can use the command =yynt-choose-project= to set the current
project. We can use =yynt-create-build= to create build objects belonging to the
project.

Here is a simple example of creating a project object:

#+begin_src elisp
  (yynt-create-project
   'egh0bww1
   "blog-build" "build.sqlite3"
   '("title" "filetags" "description" "date" "tmp"))
#+end_src

*** Create Build Object

We can use =yynt-create-build= to create build objects attached to the project. This function has quite complex parameters(wow, 16 arguments):

#+begin_src elisp
  (cl-defun yynt-create-build (&key project path type collect info collect-ex
  				  info-ex fn attrs no-cache-files ext-files
  				  published convert-fn included-resources
  				  collect-2 excluded-fn-2)
    ...)
#+end_src

- =:project=, project object to which the build object belongs
- =:path=, location of the build object, relative to the project's root directory
- =:type=, type of build object, can be the numbers 0, 1, or 2
- =:collect=, function that returns a list of files to be exported

  =:collect= accepts a function that takes a build object as a parameter and
  returns a list of absolute paths of the files to be exported, i.e., ~(bobj) =>
  (list of abs-path)~. Here is a very simple example:
  #+begin_src elisp
    (lambda (bobj)
      (mapcar (lambda (x) (file-name-concat (yynt-build--path bobj) x))
    	  '("1.org" "2.org" "3.org")))
  #+end_src
  =yynt= provides several helper functions to get the list of files: =yynt-p1=,
  =yynt-p1s=, and =yynt-p2=. =yynt-p1= accepts a regex and returns a function
  that finds files matching the regex in the directory of the build
  object. =yynt-p1s= accepts a list of files and returns a function that expands
  the file paths to absolute paths using the build object's path:
  #+begin_src elisp
    :collect (yynt-p1 "^[0-9]+\\.org")
    :collect-ex (yynt-p1s '("index.org" "tags.org"))
  #+end_src
  =yynt-p2= is mainly used for type 2 build objects. It accepts two regex
  strings as parameters: the first one matches subdirectories in the build
  object's directory, and the second one matches files to be exported in those
  subdirectories. It returns a function object that can be used as
  =:collect=. Here is an example of its usage:
  #+begin_src elisp
    :collect (yynt-p2 "^2" "\\.\\(htm\\|org\\)$")
  #+end_src
  For type 0 projects, the export files can be determined solely by =:path=;
  =:collect= has no effect.
- =:info=, =plist= of options in Org export
- =:collect-ex=, similar to =:collect=, but used to get ex files
- =:info-ex=, extra options
- =:fn=, export function
- =:attrs=, the list of keywords to be extracted from the files during export
- =:no-cache-files=, list of files not to be exported, relative to the build object
- =:ext-files=, external files that the project depends on, relative to the project
- =:published=, whether the build object is published
- =:convert-fn=, accepts the original file path and returns the export file path
- =:included-resources=, resources included in the build object, can be file and
  directory paths
- =:collect-2=, returns all the subdirectories to be exported for type 2 build objects
- =:excluded-fn-2=, returns the files and folders to be excluded in the
  subdirectories for type 2 build objects
